From 901960817a6dc7b40c68c47bcd77037d5fc5d1ea Mon Sep 17 00:00:00 2001
From: Mitch Zhu <mitchzhu@microsoft.com>
Date: Wed, 29 May 2024 19:11:14 +0000
Subject: [PATCH] Address CVE-2023-21100

If the extra field was larger than the space the user provided with
inflateGetHeader(), and if multiple calls of inflate() delivered
the extra header data, then there could be a buffer overflow of the
provided space. This commit assures that provided space is not
exceeded.
---
 deps/v8/third_party/zlib/contrib/optimizations/inflate.c | 5 +++--
 deps/v8/third_party/zlib/inflate.c                       | 5 +++--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/deps/v8/third_party/zlib/contrib/optimizations/inflate.c b/deps/v8/third_party/zlib/contrib/optimizations/inflate.c
index 4841cd96..1007f062 100644
--- a/deps/v8/third_party/zlib/contrib/optimizations/inflate.c
+++ b/deps/v8/third_party/zlib/contrib/optimizations/inflate.c
@@ -772,8 +772,9 @@ int flush;
                 if (copy > have) copy = have;
                 if (copy) {
                     if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL) {
-                        len = state->head->extra_len - state->length;
+                        state->head->extra != Z_NULL &&
++                        (len = state->head->extra_len - state->length) <
++                            state->head->extra_max) {
                         zmemcpy(state->head->extra + len, next,
                                 len + copy > state->head->extra_max ?
                                 state->head->extra_max - len : copy);
diff --git a/deps/v8/third_party/zlib/inflate.c b/deps/v8/third_party/zlib/inflate.c
index 7543c33d..384af93f 100644
--- a/deps/v8/third_party/zlib/inflate.c
+++ b/deps/v8/third_party/zlib/inflate.c
@@ -761,8 +761,9 @@ int flush;
                 if (copy > have) copy = have;
                 if (copy) {
                     if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL) {
-                        len = state->head->extra_len - state->length;
+                        state->head->extra != Z_NULL &&
++                        (len = state->head->extra_len - state->length) <
++                            state->head->extra_max) {
                         zmemcpy(state->head->extra + len, next,
                                 len + copy > state->head->extra_max ?
                                 state->head->extra_max - len : copy);
-- 
2.34.1

