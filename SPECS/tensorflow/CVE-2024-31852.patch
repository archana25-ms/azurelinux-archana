From c20c35f100a6838227435373a9511b109bca8b60 Mon Sep 17 00:00:00 2001
From: Kanishk-Bansal <kbkanishk975@gmail.com>
Date: Thu, 19 Dec 2024 08:21:17 +0000
Subject: [PATCH] Fix CVE-2024-31852 patch

Signed-off-by: Kanishk-Bansal <kbkanishk975@gmail.com>
---
 .../llvm/lib/Target/ARM/ARMFrameLowering.cpp  | 11 +++++----
 .../llvm/lib/Target/ARM/ARMFrameLowering.h    |  4 ++++
 .../lib/Target/ARM/ARMLoadStoreOptimizer.cpp  | 24 ++++++++-----------
 3 files changed, 21 insertions(+), 18 deletions(-)

diff --git a/llvm-raw/llvm/lib/Target/ARM/ARMFrameLowering.cpp b/llvm-raw/llvm/lib/Target/ARM/ARMFrameLowering.cpp
index eeb7f64aa..9b54dd4e4 100644
--- a/llvm-raw/llvm/lib/Target/ARM/ARMFrameLowering.cpp
+++ b/llvm-raw/llvm/lib/Target/ARM/ARMFrameLowering.cpp
@@ -2781,10 +2781,7 @@ void ARMFrameLowering::determineCalleeSaves(MachineFunction &MF,
   AFI->setLRIsSpilled(SavedRegs.test(ARM::LR));
 }
 
-void ARMFrameLowering::processFunctionBeforeFrameFinalized(
-    MachineFunction &MF, RegScavenger *RS) const {
-  TargetFrameLowering::processFunctionBeforeFrameFinalized(MF, RS);
-
+void ARMFrameLowering::updateLRRestored(MachineFunction &MF) {
   MachineFrameInfo &MFI = MF.getFrameInfo();
   if (!MFI.isCalleeSavedInfoValid())
     return;
@@ -2808,6 +2805,12 @@ void ARMFrameLowering::processFunctionBeforeFrameFinalized(
   }
 }
 
+void ARMFrameLowering::processFunctionBeforeFrameFinalized(
+    MachineFunction &MF, RegScavenger *RS) const {
+  TargetFrameLowering::processFunctionBeforeFrameFinalized(MF, RS);
+  updateLRRestored(MF);
+}
+
 void ARMFrameLowering::getCalleeSaves(const MachineFunction &MF,
                                       BitVector &SavedRegs) const {
   TargetFrameLowering::getCalleeSaves(MF, SavedRegs);
diff --git a/llvm-raw/llvm/lib/Target/ARM/ARMFrameLowering.h b/llvm-raw/llvm/lib/Target/ARM/ARMFrameLowering.h
index 8d2b8beb9..3c7358d8c 100644
--- a/llvm-raw/llvm/lib/Target/ARM/ARMFrameLowering.h
+++ b/llvm-raw/llvm/lib/Target/ARM/ARMFrameLowering.h
@@ -59,6 +59,10 @@ public:
   void determineCalleeSaves(MachineFunction &MF, BitVector &SavedRegs,
                             RegScavenger *RS) const override;
 
+  /// Update the IsRestored flag on LR if it is spilled, based on the return
+  /// instructions.
+  static void updateLRRestored(MachineFunction &MF);
+
   void processFunctionBeforeFrameFinalized(
       MachineFunction &MF, RegScavenger *RS = nullptr) const override;
 
diff --git a/llvm-raw/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp b/llvm-raw/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
index ed9d30c3c..7a817ab94 100644
--- a/llvm-raw/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
+++ b/llvm-raw/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp
@@ -2062,17 +2062,6 @@ bool ARMLoadStoreOpt::MergeReturnIntoLDM(MachineBasicBlock &MBB) {
       MO.setReg(ARM::PC);
       PrevMI.copyImplicitOps(*MBB.getParent(), *MBBI);
       MBB.erase(MBBI);
-      // We now restore LR into PC so it is not live-out of the return block
-      // anymore: Clear the CSI Restored bit.
-      MachineFrameInfo &MFI = MBB.getParent()->getFrameInfo();
-      // CSI should be fixed after PrologEpilog Insertion
-      assert(MFI.isCalleeSavedInfoValid() && "CSI should be valid");
-      for (CalleeSavedInfo &Info : MFI.getCalleeSavedInfo()) {
-        if (Info.getReg() == ARM::LR) {
-          Info.setRestored(false);
-          break;
-        }
-      }
       return true;
     }
   }
@@ -2120,15 +2109,22 @@ bool ARMLoadStoreOpt::runOnMachineFunction(MachineFunction &Fn) {
   isThumb2 = AFI->isThumb2Function();
   isThumb1 = AFI->isThumbFunction() && !isThumb2;
 
-  bool Modified = false;
+  bool Modified = false, ModifiedLDMReturn = false;
   for (MachineBasicBlock &MBB : Fn) {
     Modified |= LoadStoreMultipleOpti(MBB);
     if (STI->hasV5TOps() && !AFI->shouldSignReturnAddress())
-      Modified |= MergeReturnIntoLDM(MBB);
+      ModifiedLDMReturn |= MergeReturnIntoLDM(MBB);
     if (isThumb1)
       Modified |= CombineMovBx(MBB);
   }
-
+  Modified |= ModifiedLDMReturn;
+  // If we merged a BX instruction into an LDM, we need to re-calculate whether
+  // LR is restored. This check needs to consider the whole function, not just
+  // the instruction(s) we changed, because there may be other BX returns which
+  // still need LR to be restored.
+  if (ModifiedLDMReturn)
+    ARMFrameLowering::updateLRRestored(Fn);
+  
   Allocator.DestroyAll();
   return Modified;
 }
-- 
2.45.2

