From 273e273503f10f099c36c57c49ffed6fc234ed3c Mon Sep 17 00:00:00 2001
From: archana25-ms <v-shettigara@microsoft.com>
Date: Fri, 11 Apr 2025 08:00:23 +0000
Subject: [PATCH] Address CVE-2024-50615

Upstream Patch Reference: https://github.com/leethomason/tinyxml2/commit/4cbb25155cde261ccf868efb8ae29ad0eebea4d1
---
 tinyxml2.cpp | 123 +++++++++++++++++++++++----------------------------
 1 file changed, 55 insertions(+), 68 deletions(-)

diff --git a/tinyxml2.cpp b/tinyxml2.cpp
index 861e7d4..feb9fee 100755
--- a/tinyxml2.cpp
+++ b/tinyxml2.cpp
@@ -467,9 +467,9 @@ void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length
 }
 
 
-const char* XMLUtil::GetCharacterRef( const char* p, char* value, int* length )
+const char* XMLUtil::GetCharacterRef(const char* p, char* value, int* length)
 {
-    // Presume an entity, and pull it out.
+    // Assume an entity, and pull it out.
     *length = 0;
 
     static const uint32_t MAX_CODE_POINT = 0x10FFFF;
@@ -480,91 +480,78 @@ const char* XMLUtil::GetCharacterRef( const char* p, char* value, int* length )
         uint32_t mult = 1;
         static const char SEMICOLON = ';';
 
-        if ( *(p+2) == 'x' ) {
-            // Hexadecimal.
-            const char* q = p+3;
-            if ( !(*q) ) {
-                return 0;
-            }
-
-            q = strchr( q, SEMICOLON );
-            if ( !q ) {
-                return 0;
-            }
-            TIXMLASSERT( *q == SEMICOLON );
-
-            delta = q-p;
-            --q;
+        bool hex = false;
+        uint32_t radix = 10;
+        const char* q = 0;
+        char terminator = '#';
 
-            while ( *q != 'x' ) {
-                uint32_t int digit = 0;
+        if (*(p + 2) == 'x') {
+            // Hexadecimal.
+            hex = true;
+            radix = 16;
+            terminator = 'x';
 
-                if ( *q >= '0' && *q <= '9' ) {
-                    digit = *q - '0';
-                }
-                else if ( *q >= 'a' && *q <= 'f' ) {
-                    digit = *q - 'a' + 10;
-                }
-                else if ( *q >= 'A' && *q <= 'F' ) {
-                    digit = *q - 'A' + 10;
-                }
-                else {
-                    return 0;
-                }
-                TIXMLASSERT( digit < 16 );
-                const unsigned int digitScaled = mult * digit;
-                ucs += digitScaled;
-			if (ucs > MAX_CODE_POINT) {
- 				return 0;
- 			}
-
-                mult *= 16;
-                --q;
-            }
+            q = p + 3;
+            q = p + 3;
         }
         else {
             // Decimal.
-            const char* q = p+2;
-            if ( !(*q) ) {
-                return 0;
-            }
+            q = p + 2;
+        }
+        if (!(*q)) {
+            return 0;
+        }
+
+
+        q = strchr(q, SEMICOLON);
+        if (!q) {
+            return 0;
+        }
+        TIXMLASSERT(*q == SEMICOLON);
+        delta = q - p;
+        --q;
 
-            q = strchr( q, SEMICOLON );
+        while (*q != terminator) {
+            uint32_t digit = 0;
 
-            if ( !q ) {
+            if (*q >= '0' && *q <= '9') {
+                digit = *q - '0';
+            }
+            else if (hex && (*q >= 'a' && *q <= 'f')) {
+                digit = *q - 'a' + 10;
+            }
+            else if (hex && (*q >= 'A' && *q <= 'F')) {
+                digit = *q - 'A' + 10;
+            }
+            else {
                 return 0;
             }
-            TIXMLASSERT( *q == SEMICOLON );
+            TIXMLASSERT(digit < radix);
 
-            delta = q-p;
-            --q;
+            const unsigned int digitScaled = mult * digit;
+            ucs += digitScaled;
+            mult *= radix;       
 
-            while ( *q != '#' ) {
-                if ( *q >= '0' && *q <= '9' ) {
-                    const uint32_t int digit = *q - '0';
-                    TIXMLASSERT( digit < 10 );
-		    const uint32_t digitScaled = mult * digit;
-                    ucs += digitScaled;
-		    if (ucs > MAX_CODE_POINT) {
-                         return 0;
-                    }
-                }
-                else {
-                    return 0;
-                }
-                mult *= 10;
-                --q;
+            // Security check: could a value exist that is out of range?
+            // Easily; limit to the MAX_CODE_POINT, which also allows for a
+            // bunch of leading zeroes.
+            if (mult > MAX_CODE_POINT) {
+                mult = MAX_CODE_POINT;
             }
+            --q;
+        }
+        // Out of range:
+        if (ucs > MAX_CODE_POINT) {
+            return 0;
         }
         // convert the UCS to UTF-8
 		TIXMLASSERT(ucs <= MAX_CODE_POINT);
-        ConvertUTF32ToUTF8( ucs, value, length );
+        ConvertUTF32ToUTF8(ucs, value, length);
         return p + delta + 1;
     }
-    return p+1;
+    return p + 1;
 }
 
-
 void XMLUtil::ToStr( int v, char* buffer, int bufferSize )
 {
     TIXML_SNPRINTF( buffer, bufferSize, "%d", v );
-- 
2.45.3

